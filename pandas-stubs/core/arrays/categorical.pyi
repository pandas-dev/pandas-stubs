from collections.abc import (
    Callable,
    Container,
    Hashable,
    Sequence,
)
import sys
from typing import (
    Any,
    overload,
)

import numpy as np
import numpy.typing as npt
from pandas import Series
from pandas.core.accessor import PandasDelegate as PandasDelegate
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.base import NoNewAttributesMixin as NoNewAttributesMixin
from pandas.core.indexes.base import Index
from pandas.core.indexes.category import CategoricalIndex
from typing_extensions import Self

from pandas._typing import (
    AnyArrayLike,
    ListLike,
    NpDtype,
    Ordered,
    PositionalIndexerTuple,
    Renamer,
    Scalar,
    ScalarIndexer,
    SequenceIndexer,
    np_1darray,
    np_1darray_bool,
)

from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype

def contains(
    cat: Categorical | CategoricalIndex, key: Hashable, container: Container
) -> bool: ...

class Categorical(ExtensionArray):
    __array_priority__: int = ...
    def __init__(
        self,
        values: ListLike,
        categories: ListLike | None = None,
        ordered: bool | None = None,
        dtype: CategoricalDtype | None = None,
        fastpath: bool = True,
    ) -> None: ...
    @property
    def categories(self) -> Index: ...
    @property
    def ordered(self) -> Ordered: ...
    @property
    def dtype(self) -> CategoricalDtype: ...
    def size(self) -> int: ...
    def tolist(self) -> list[Scalar]: ...
    to_list = ...
    @classmethod
    def from_codes(
        cls,
        codes: Sequence[int],
        categories: Index | None = ...,
        ordered: bool | None = ...,
        dtype: CategoricalDtype | None = ...,
        fastpath: bool = ...,
    ) -> Categorical: ...
    @property
    def codes(self) -> np_1darray[np.signedinteger]: ...
    def set_ordered(self, value: bool) -> Categorical: ...
    def as_ordered(self) -> Categorical: ...
    def as_unordered(self) -> Categorical: ...
    def set_categories(
        self,
        new_categories: AnyArrayLike,
        ordered: bool | None = False,
        rename: bool = False,
    ) -> Categorical: ...
    def rename_categories(self, new_categories: AnyArrayLike) -> Categorical: ...
    def reorder_categories(
        self, new_categories: AnyArrayLike, ordered: bool | None = ...
    ) -> Categorical: ...
    def remove_unused_categories(self) -> Categorical: ...
    def map(self, mapper: Renamer) -> CategoricalIndex | Index: ...
    def __array__(
        self, dtype: NpDtype | None = None, copy: bool | None = None
    ) -> np_1darray: ...
    @property
    def T(self) -> Self: ...
    @property
    def nbytes(self) -> int: ...
    def memory_usage(self, deep: bool = False) -> int: ...
    def isna(self) -> np_1darray_bool: ...
    def isnull(self) -> np_1darray_bool: ...
    def notna(self) -> np_1darray_bool: ...
    def notnull(self) -> np_1darray_bool: ...
    def value_counts(self, dropna: bool = True) -> Series: ...
    def check_for_ordered(self, op: Any) -> None: ...
    if sys.version_info >= (3, 11):
        def argsort(
            self, *, ascending: bool = ..., kind: str = ..., **kwargs: Any
        ) -> npt.NDArray[np.intp]: ...
    else:
        def argsort(
            self, *, ascending: bool = ..., kind: str = ..., **kwargs: Any
        ) -> np.ndarray[tuple[int], ...]: ...

    def sort_values(
        self, *, inplace: bool = ..., ascending: bool = ..., na_position: str = ...
    ) -> Self: ...
    def __contains__(self, item: Hashable) -> bool: ...
    @overload
    def __getitem__(  # pyrefly: ignore[bad-override,bad-param-name-override]
        self, key: ScalarIndexer
    ) -> Any: ...
    @overload
    def __getitem__(  # ty: ignore[invalid-method-override]
        self, key: SequenceIndexer | PositionalIndexerTuple
    ) -> Self: ...

class CategoricalAccessor(PandasDelegate, NoNewAttributesMixin):
    def __init__(self, data: Series | CategoricalIndex) -> None: ...
    @property
    def codes(self) -> Series[int]: ...
    @property
    def categories(self) -> Index: ...
    @property
    def ordered(self) -> bool | None: ...
    def rename_categories(
        self, new_categories: ListLike | dict[Any, Any] | Callable[[Any], Any]
    ) -> Series: ...
    def reorder_categories(
        self,
        new_categories: ListLike,
        ordered: bool = ...,
    ) -> Series: ...
    def add_categories(self, new_categories: Scalar | ListLike) -> Series: ...
    def remove_categories(self, removals: Scalar | ListLike) -> Series: ...
    def remove_unused_categories(self) -> Series: ...
    def set_categories(
        self,
        new_categories: ListLike,
        ordered: bool | None = False,
        rename: bool = False,
    ) -> Series: ...
    def as_ordered(self) -> Series: ...
    def as_unordered(self) -> Series: ...
