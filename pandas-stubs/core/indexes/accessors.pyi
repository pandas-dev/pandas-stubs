from datetime import tzinfo
from typing import (
    Literal,
    Optional,
    Union,
)

import numpy as np
import numpy.typing as npt
from pandas import Timedelta
from pandas.core.accessor import PandasDelegate
from pandas.core.arrays import (
    DatetimeArray,
    PeriodArray,
)
from pandas.core.base import (
    NoNewAttributesMixin,
    PandasObject,
)
from pandas.core.frame import DataFrame
from pandas.core.series import (
    Series,
    TimestampSeries,
)

from pandas._libs.tslibs import BaseOffset
from pandas._libs.tslibs.offsets import DateOffset
from pandas._typing import np_ndarray_bool

class Properties(PandasDelegate, PandasObject, NoNewAttributesMixin):
    def __init__(self, data: Series, orig) -> None: ...

class DatetimeProperties(Properties):
    def to_pydatetime(self) -> np.ndarray: ...
    @property
    def freq(self) -> str: ...
    def isocalendar(self) -> DataFrame: ...
    @property
    def weekofyear(self) -> int: ...
    @property
    def week(self) -> int: ...
    @property
    def is_month_start(self) -> bool: ...
    @property
    def is_month_end(self) -> bool: ...
    @property
    def is_quarter_start(self) -> bool: ...
    @property
    def is_quarter_end(self) -> bool: ...
    @property
    def is_year_start(self) -> bool: ...
    @property
    def is_year_end(self) -> bool: ...
    @property
    def is_leap_year(self) -> bool: ...
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> int: ...
    @property
    def weekday(self) -> int: ...
    @property
    def dayofweek(self) -> int: ...
    @property
    def day_of_week(self) -> int: ...
    @property
    def dayofyear(self) -> int: ...
    @property
    def day_of_year(self) -> int: ...
    @property
    def quarter(self) -> int: ...
    @property
    def days_in_month(self) -> int: ...
    @property
    def daysinmonth(self) -> int: ...
    @property
    def microsecond(self) -> int: ...
    @property
    def nanosecond(self) -> int: ...
    @property
    def tz(self) -> Optional[tzinfo]: ...
    @property
    def date(self) -> npt.NDArray[np.object_]: ...
    @property
    def time(self) -> npt.NDArray[np.object_]: ...
    @property
    def timetz(self) -> npt.NDArray[np.object_]: ...
    def to_period(
        self, freq: Optional[Union[str, BaseOffset]] = ...
    ) -> PeriodArray: ...
    def tz_localize(
        self,
        tz: Optional[str],
        ambiguous: Union[Literal["raise", "infer", "NaT"], np_ndarray_bool] = ...,
        nonexistent: Union[
            Literal["shift_forward", "shift_backward", "NaT", "raise"], Timedelta
        ] = ...,
    ) -> DatetimeArray: ...
    def tz_convert(self, tz: Optional[str]) -> DatetimeArray: ...
    def normalize(self) -> DatetimeArray: ...
    def strftime(self, date_format: str) -> npt.NDArray[np.object_]: ...
    # Ideally, the next 3 methods would return TimestampSeries, but because of
    # how Series.dt is hooked in, we don't know which kind of series was passed
    # in to the dt accessor
    def round(
        self,
        freq: Optional[Union[str, BaseOffset]],
        ambiguous: Union[Literal["raise", "infer", "NaT"], np_ndarray_bool] = ...,
        nonexistent: Union[
            Literal["shift_forward", "shift_backward", "NaT", "raise"], Timedelta
        ] = ...,
    ) -> Series: ...
    def floor(
        self,
        freq: Optional[Union[str, BaseOffset]],
        ambiguous: Union[Literal["raise", "infer", "NaT"], np_ndarray_bool] = ...,
        nonexistent: Union[
            Literal["shift_forward", "shift_backward", "NaT", "raise"], Timedelta
        ] = ...,
    ) -> Series: ...
    def ceil(
        self,
        freq: Optional[Union[str, BaseOffset]],
        ambiguous: Union[Literal["raise", "infer", "NaT"], np_ndarray_bool] = ...,
        nonexistent: Union[
            Literal["shift_forward", "shift_backward", "NaT", "raise"], Timedelta
        ] = ...,
    ) -> Series: ...
    def month_name(self, locale: Optional[str] = ...) -> npt.NDArray[np.object_]: ...
    def day_name(self, locale: Optional[str] = ...) -> npt.NDArray[np.object_]: ...

class TimedeltaProperties(Properties):
    def to_pytimedelta(self) -> np.ndarray: ...
    @property
    def components(self) -> DataFrame: ...
    @property
    def freq(self) -> str: ...
    @property
    def days(self) -> int: ...
    @property
    def seconds(self) -> int: ...
    @property
    def microseconds(self) -> int: ...
    @property
    def nanoseconds(self) -> int: ...
    def total_seconds(self) -> npt.NDArray[np.float64]: ...
    # Ideally, the next 3 methods would return TimedeltaSeries, but because of
    # how Series.dt is hooked in, we don't know which kind of series was passed
    # in to the dt accessor
    def round(
        self,
        freq: Optional[Union[str, BaseOffset]],
        ambiguous: Union[Literal["raise", "infer", "NaT"], np_ndarray_bool] = ...,
        nonexistent: Union[
            Literal["shift_forward", "shift_backward", "NaT", "raise"], Timedelta
        ] = ...,
    ) -> Series: ...
    def floor(
        self,
        freq: Optional[Union[str, BaseOffset]],
        ambiguous: Union[Literal["raise", "infer", "NaT"], np_ndarray_bool] = ...,
        nonexistent: Union[
            Literal["shift_forward", "shift_backward", "NaT", "raise"], Timedelta
        ] = ...,
    ) -> Series: ...
    def ceil(
        self,
        freq: Optional[Union[str, BaseOffset]],
        ambiguous: Union[Literal["raise", "infer", "NaT"], np_ndarray_bool] = ...,
        nonexistent: Union[
            Literal["shift_forward", "shift_backward", "NaT", "raise"], Timedelta
        ] = ...,
    ) -> Series: ...

class PeriodProperties(Properties):
    @property
    def is_leap_year(self) -> bool: ...
    @property
    def start_time(self) -> TimestampSeries: ...
    @property
    def end_time(self) -> TimestampSeries: ...
    @property
    def freq(self) -> str: ...
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> int: ...
    @property
    def weekofyear(self) -> int: ...
    @property
    def weekday(self) -> int: ...
    @property
    def week(self) -> int: ...
    @property
    def dayofweek(self) -> int: ...
    @property
    def day_of_week(self) -> int: ...
    @property
    def dayofyear(self) -> int: ...
    @property
    def day_of_year(self) -> int: ...
    @property
    def quarter(self) -> int: ...
    @property
    def qyear(self) -> int: ...
    @property
    def days_in_month(self) -> int: ...
    @property
    def daysinmonth(self) -> int: ...
    def strftime(self, date_format: str) -> npt.NDArray[np.object_]: ...
    def to_timestamp(
        self,
        freq: Optional[Union[str, DateOffset]] = ...,
        how: Literal["s", "e", "start", "end"] = ...,
    ) -> DatetimeArray: ...
    def asfreq(
        self,
        freq: Optional[Union[str, DateOffset]] = ...,
        how: Literal["E", "END", "FINISH", "S", "START", "BEGIN"] = ...,
    ) -> PeriodArray: ...

class CombinedDatetimelikeProperties(
    DatetimeProperties, TimedeltaProperties, PeriodProperties
):
    def __new__(cls, data: Series): ...
